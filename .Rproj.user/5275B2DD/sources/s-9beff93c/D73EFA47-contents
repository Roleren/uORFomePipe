#' Create GRangesList of ORF IDs
#' @param uniqueIDS a character vector of ORF ids
#' @return GRangesList
#' @importFrom splitstackshape cSplit
toGRFromUniqueID <- function(uniqueIDs = readTable("uniqueIDs")){

  if (class(uniqueIDs)[1] != "data.table"){
    if (class(uniqueIDs)[1] == "character"){
      uniqueIDs <- data.table(uorfID = uniqueIDs)
    } else stop("uniqueIDs must either be data.table or character!")
  }else if (ncol(uniqueIDs) != 1) stop("must only be 1 column")
  colnames(uniqueIDs) = "uorfID"

  splitList <- fread(text = uniqueIDs$uorfID, sep = ",", header = FALSE)

  if (ncol(splitList) != 3) stop("not correct ncols in uniqueIDs")
  colnames(splitList) <- paste0("uorfID_", 1:3)
  maxCols <- max(nchar(gsub("[^;]*", "", splitList$uorfID_3)))

  # TODO: Find a way to remove splitstackshape
  a <- splitstackshape::cSplit(splitList, splitCols = "uorfID_3",
                               sep = ";", drop = T)
  # Set strand and seqnames (col 1 and 2)
  seqnamesUsed <- as.character(unlist(a[,1]))
  strands <- as.character(unlist(a[,2]))
  a <- a[,-c(1,2)]

  # Split on exons
  exonsList <- as.data.table(matrix(ncol = ncol(a)*2, nrow = nrow(a)))
  j = 1
  for(i in seq.int(ncol(a))) {
    exons <- splitstackshape::cSplit(splitCols = 1,indt = a[, i, with=F],  sep = " ", drop = T)
    exonsList[,j] <- exons[,1]
    exonsList[,ncol(a)+j] <- exons[,2]
    j <- j + 1
  }

  starts <- exonsList[, 1:ncol(a)]
  widths <- exonsList[, (ncol(a)+1):(ncol(a)*2)]
  rm(exonsList)
  rm(exons)
  rm(a)
  counts <- rowSums(!is.na(starts))
  t <- unlist(lapply(seq.int(length(counts)), function(x) {
    rep.int(x, counts[x])
  }))

  #IntegerLists
  starts <- c(t(starts))
  starts <- starts[!is.na(starts)]
  widths <- c(t(widths))
  widths <- widths[!is.na(widths)]

  gr = GRanges(seqnames = seqnamesUsed[t],
               ranges = IRanges(start = starts, width = widths),
               strand = strands[t])

  grl = groupGRangesBy(gr,t)
  grl <- sortPerGroup(grl)

  #test the orfs
  widths <- ORFik:::widthPerGroup(grl, F)
  if(all((widths %% 3) == 0)) stop("widths of uorfs are not %3 = 0!")
  if (length(grl) != nrow(uniqueIDs)) stop("not all ranges was reconstructed properly, check data!")
  return(grl)
}

#' Get negative transcripts
#' with > 1 exon
getNegExonGrl <- function(grl) {
  grl <- grl[!strandBool(grl)]
  grl <- grl[ORFik:::numExonsPerGroup(grl) > 1]
  return(grl)
}
